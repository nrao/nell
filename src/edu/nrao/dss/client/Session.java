package edu.nrao.dss.client;

import java.util.ArrayList;
import java.util.List;

import com.google.gwt.json.client.JSONArray;
import com.google.gwt.json.client.JSONObject;
import com.google.gwt.widgetideas.graphics.client.Color;

/** A simplified representation of sessions designed for use in the overview calendar. */
@SuppressWarnings("unchecked")
class Session implements Comparable {
    /** Parse the list of sessions and opportunities generated by the server. */
    public static List<Session> parseJSON(JSONObject json) {
        return parseWindows(json.get("windows").isArray());
    }

    /** Parse the list of sessions and opportunities generated by the server. */
    private static List<Session> parseWindows(JSONArray windows) {
        ArrayList<Session> sessions = new ArrayList<Session>();
        for (int i = 0; i < windows.size(); ++i) {
            Session session = parseWindow(windows.get(i).isObject());
            if (session.getNumIntervals() > 0) {
                sessions.add(session);
            }
        }
        return sessions;
    }

    /** Parse an individual session with its opportunities. */
    private static Session parseWindow(JSONObject window) {
        int id = (int) window.get("id").isNumber().doubleValue();
        Session session = new Session(id);

        List<Interval> intervals = Interval.parseIntervals(session, window.get("opportunities").isArray());
        session.setIntervals(intervals);
        return session;
    }

    public Session(int id) {
        this.id = id;
    }

    public boolean contains(int day, int hour) {
        int startDay  = getStartDay();
        int startHour = getStartHour() % 24;
        int numDays   = getNumDays();
        int numHours  = getNumHours();

        if (startHour + numHours > 24) {
            return (startDay <= day && day < startDay + numDays && startHour <= hour && hour < 24) ||
                   (startDay+1 <= day && day < startDay + numDays + 1 && 0 <= hour && hour < startHour + numHours - 24);
        }
        return startDay <= day && day < startDay + numDays && startHour <= hour && hour < startHour + numHours;
    }

    public void draw(Calendar grid) {
        int startDay  = getStartDay();
        int startHour = getStartHour() % 24;
        int numDays   = getNumDays();
        int numHours  = getNumHours();

        grid.setFillStyle(getColor());
        grid.fillRect(startDay, startHour, numDays, numHours);
        if (numDays == 1) {
            grid.setStrokeStyle(new Color(0, 0, 0, getAlpha()));
            grid.setLineWidth(4);
            grid.strokeRect(startDay, startHour, 1, numHours);
        }
    }

    /** Return the number of opportunities. */
    public int getNumIntervals() {
        return intervals.size();
    }

    /** Return a list of opportunities. */
    public List<Interval> getIntervals() {
        return intervals;
    }

    /** Record the opportunities available to a given fixed or windowed session. */
    public void setIntervals(List<Interval> intervals) {
        this.intervals = new ArrayList<Interval>();

        // We're not prepared to deal with anything beyond the current trimester.
        for (Interval interval : intervals) {
            if (0 <= interval.getStartDay() && interval.getStartDay() < 120) {
                this.intervals.add(interval);
            }
        }
    }

    public int compareTo(Object other) {
        Session rhs = (Session) other;

        // Note that shorter sessions sort *after* longer sessions.  This is so that
        // shorter sessions get drawn on top of longer ones in the UI.
        if (getStartHour() <  rhs.getStartHour())                                       { return -1; }
        if (getStartHour() == rhs.getStartHour() && getNumHours() >  rhs.getNumHours()) { return -1; }
        if (getStartHour() == rhs.getStartHour() && getNumHours() == rhs.getNumHours()) { return  0; }
        return +1;
    }

    /** A window begins on the day of its first opportunity. */
    public int getStartDay() {
        return intervals.get(0).getStartDay();
    }

    private int getNumDays() {
        int startDay = getStartDay();
        int endDay   = intervals.get(intervals.size()-1).getStartDay();
        return endDay - startDay + 1;
    }

    public int getStartHour() {
        return intervals.get(0).getStartHour();
    }

    public int getNumHours() {
        return intervals.get(0).getNumHours();
    }

    public void setStartDay(int day) {
        int deltaDays = day - getStartDay();
        for (Interval interval : intervals) {
            interval.setStartDay(interval.getStartDay() + deltaDays);
        }
    }

    public Color getColor() {
		return new Color(red, green, blue, alpha);
	}

    public float getAlpha() {
		return alpha;
	}

    public void setRGB(int red, int green, int blue) {
		this.red   = red;
		this.green = green;
		this.blue  = blue;
	}

    public void setAlpha(float alpha) {
		this.alpha = alpha;
	}

    public String getInfoText() {
		return "" + id + infoText;
	}

    public void setInfoText(String infoText) {
		this.infoText = infoText;
	}

    private int   id    = 0;
	private List<Interval> intervals;

	private int   red   = 0;
	private int   green = 0;
	private int   blue  = 0;
	private float alpha = 1.0f;

	private String infoText = "";
}
